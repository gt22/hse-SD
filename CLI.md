Команда: Энгель Игорь, Вавилов Марк

Диаграммы: по файлу на этап в репозитории

## Shell   
Центральный класс, содержит основной цикл приложения

`environment: Map<String, String>` - набор переменных окружения  

`fun execute(line: String): Int` - с помощью `parser` преобразует поданную на вход строку в `CommandPipeline`, создаёт базовый контекст (на основе stdin/stdout) и вызывает `execute`.

## Parser
Класс отвечающий за разбиение строки на команды

`commands: List<AbstractCommand>` - список известных команд

Строка разбивается на токены с учётом кавычек, выполняются подстановки.

Список токенов разбивается на разные компоненты пайпа, для каждого компонента создаётся `PreparedCommand`, все вместе они собираются в `CommandPipeline`
  
### Понятия

Компонент пайпа -- список токенов, где первый токен - команда, остальные - аргументы команды. Компоненты пайпа разделены `|`. 

Токены -- команда и каждый отдельный аргумент. 
Токены разделяются пробелами, но кавычки позволяют положить в один токен текст с пробелами. 
Все внутри кавычек принадлежит одному токену. 


### Как учитываются кавычки
Внутренность кавычек - текст начиная с кавычки до ближайшей такой же кавычки. 
Кавычки другого типа внутри - обычные символы. Парсер убирает кавычки.

Все внутри одинарных кавычек остается как было, внутри двойных производится замена переменных.

Пример: при `x=v` `"'$x'"` раскрывается в `'v'`, т.к. одинарные кавычки внутри двойных - обычные символы. 

### Переменные
Переменные задаются выражением типа `variable=value`, где имя переменной может состоять из букв, цифр и нижних подчеркиваний. 

Значение - то же самое, что токен. К примеру, в `x="'x y z'"` значением является все, что в двойных кавычках без изменений. 

#### Раскрытие переменных

Текст начиная с `$` и до символов, недопустимых в названиях переменных, раскрываются в значение переменной.
Если такой переменной нет, считаем, что значение переменной - пустая строка

Переменные раскрываются кроме случая, когда они в одинарных кавычках. Переменные раскрываются внутрь одного токена, как если бы они раскрывались внутри кавычек.

Поэтому, к примеру, `$x$s$y`, где `x=echo; s=' '; y='5'`, раскроется как `"echo 5"`, то есть как один токен и будет считаться названием команды.


### После разбиения на текстовые токены

Первый токен в каждом компоненте пайпа - название команды. Создается `PreparedCommand` путём итерации по `commands`, и вызову `match`. 
Из них создается и возвращается `CommandPipeline`.
  


## CommandPipeline  
Класс содержащий цепочку команд и отвечающий за их последовательное исполнение 

`commands: List<PreparedCommand>` - последовательность составных команд

`fun execute(ctx: CommandContext): Int` - запускает все команды последовательно, перенаправляя вывод одной на вход другой. Возвращаемое значение - результат последней команды.

## AbstractCommand
Абстрактный класс команды

`match` - проверяем задаёт-ли переданная строка данную команду, используется парсером

`execute` - выполняет команду, возвращает код выполнения, ввод/вывод/переменные среды берутся из контекста

## SimpleCommand
Класс "стандартных" команд первым токеном которых обязано быть конкретное слово

`name` - название команды

Реализация `match` - проверяем что первый элемент совпадает с названием команды

## CommandSetEnviron
Команда вида `x=y`, устанавливающая переменные среды

## PreparedCommand  
  
По сути пара команда + её аргументы
